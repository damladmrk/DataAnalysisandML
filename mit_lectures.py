# -*- coding: utf-8 -*-
"""mit_lectures

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mFmiOtP5PVOFuCC9v4Yoa5W288yEkXT8
"""

import random
import pylab
import numpy as np
#6.006 - 6.034 - 6.036


class SimpleVirus(object):
    def __init__(self, maxBirthProb, clearProb):
        self.maxBirthProb = maxBirthProb
        self.clearProb = clearProb

    def getMaxBirthProb(self):
        return self.maxBirthProb

    def getClearProb(self):
        return self.clearProb

    def doesClear(self):
        return random.random() < min(1, self.getClearProb())

    def reproduce(self, popDensity):
        if random.random() < self.maxBirthProb * (1 - popDensity):
            return SimpleVirus(self.maxBirthProb, self.clearProb)
        elif self.maxBirthProb == 0:
            raise NoChildException
        else:
            raise NoChildException



class Patient(object):

    def __init__(self, viruses, maxPop):
      self.viruses = viruses
      self.maxPop = maxPop

    def getViruses(self):
        return self.viruses

    def getMaxPop(self):
        return self.maxPop

    def getTotalPop(self):
        return len(self.viruses)

    def update(self):
        viruses_copy = self.viruses[:]
        for i in viruses_copy:
            if i.doesClear() == True:
                self.viruses.remove(i)

        popDensity = len(self.viruses)/self.maxPop

        viruses_copy_2 = self.viruses[:]
        for j in viruses_copy_2:
            try:
                j.reproduce(popDensity)
                self.viruses.append(j)
            except NoChildException:
                continue

class NoChildException(Exception):
  print('NCE error')


def simulationWithoutDrug(numViruses, maxPop, maxBirthProb, clearProb, numTrials):

    data = np.zeros(300)
    for i in range(numTrials):
        virus = SimpleVirus(maxBirthProb, clearProb)
        viruses = [virus] * numViruses
        patient = Patient(viruses, maxPop)
        virus_count = []
        for j in range(300):
            patient.update()
            virus_count.append(patient.getTotalPop())
        data = data + virus_count
    data_avg = data/numTrials

    pylab.plot(list(data_avg), label=r'Average SimpleVirus Population')
    pylab.xlabel(r'Number of steps')
    pylab.ylabel(r'Virus Population')
    pylab.title(r'Simple Virus Simulation in Patient')
    pylab.legend()
    pylab.show()

simulationWithoutDrug(100, 300, 0.5, 0.3, 300)

class ResistantVirus(SimpleVirus):
    def __init__(self, maxBirthProb, clearProb, resistances, mutProb):
        SimpleVirus.__init__(self, maxBirthProb, clearProb)
        self.resistances = resistances
        self.mutProb = mutProb

    def getResistances(self):
        return self.resistances

    def getMutProb(self):
        return self.mutProb

    def isResistantTo(self, drug):
        return self.resistances.get(drug, False)

    def reproduce(self, popDensity, activeDrugs):
        if all(self.isResistantTo(drug) for drug in activeDrugs) and random.random() < (self.maxBirthProb * (1 - popDensity)):
            child_resistances = dict(self.resistances)
            for drug in self.resistances:
                if random.random() < self.mutProb:
                    child_resistances[drug] = not child_resistances[drug]
            return ResistantVirus(self.maxBirthProb, self.clearProb, child_resistances, self.mutProb)
        else:
            raise NoChildException



class TreatedPatient(Patient):

    def __init__(self, viruses, maxPop):
        self.viruses = viruses
        self.maxPop = maxPop
        self.drug_list = []
        Patient.__init__(self, viruses, maxPop)


    def addPrescription(self, newDrug):
        if newDrug not in self.drug_list:
          self.drug_list.append(newDrug)


    def getPrescriptions(self):
        return self.drug_list


    def getResistPop(self, drugResist):
        resist_count = 0
        for virus in self.viruses:
            if all(virus.isResistantTo(drug) for drug in drugResist):
                resist_count += 1

        return resist_count


    def update(self):
        viruses_copy = self.viruses[:]
        for i in viruses_copy:
            if i.doesClear() == True:
                self.viruses.remove(i)

        popDensity = len(self.viruses)/self.maxPop

        viruses_copy_2 = self.viruses[:]
        for j in viruses_copy_2:
            try:
                j.reproduce(popDensity, self.drug_list)
                self.viruses.append(j)
            except NoChildException:
                continue

import random
import pylab


def simulationWithDrug(numViruses, maxPop, maxBirthProb, clearProb, resistances,
                       mutProb, numTrials):
    """
    Runs simulations and plots graphs for problem 5.

    For each of numTrials trials, instantiates a patient, runs a simulation for
    150 timesteps, adds guttagonol, and runs the simulation for an additional
    150 timesteps.  At the end plots the average virus population size
    (for both the total virus population and the guttagonol-resistant virus
    population) as a function of time.

    numViruses: number of ResistantVirus to create for patient (an integer)
    maxPop: maximum virus population for patient (an integer)
    maxBirthProb: Maximum reproduction probability (a float between 0-1)
    clearProb: maximum clearance probability (a float between 0-1)
    resistances: a dictionary of drugs that each ResistantVirus is resistant to
                 (e.g., {'guttagonol': False})
    mutProb: mutation probability for each ResistantVirus particle
             (a float between 0-1).
    numTrials: number of simulation runs to execute (an integer)
    """
    time_steps = 300
    total_populations = [0] * time_steps
    resistant_populations = [0] * time_steps

    for t in range(numTrials):
        viruses = [ResistantVirus(maxBirthProb, clearProb, resistances, mutProb) for _ in range(numViruses)]
        patient = TreatedPatient(viruses, maxPop)

        for s in range(150):
            total_population = patient.update()
            resistant_population = patient.getResistPop(['guttagonol'])

            total_populations[s] += total_population
            resistant_populations[s] += resistant_population

        patient.addPrescription('guttagonol')

        for s in range(150, 300):
            total_population = patient.update()
            resistant_population = patient.getResistPop(['guttagonol'])

            total_populations[s] += total_population
            resistant_populations[s] += resistant_population

    average_total_populations = [x / numTrials for x in total_populations]
    average_resistant_populations = [x / numTrials for x in resistant_populations]

    pylab.plot(average_total_populations, label="Total Virus Population")
    pylab.plot(average_resistant_populations, label="Resistant Virus Population")
    pylab.title("Virus Population Over Time with Drug Treatment")
    pylab.xlabel("Time Steps")
    pylab.ylabel("Average Virus Population")
    pylab.legend(loc="best")
    pylab.show()

simulationWithDrug(numViruses = 100, maxPop = 1000, maxBirthProb = 0.2, clearProb = 0.05, resistances = {'guttagonol': False}, mutProb = 0.005, numTrials = 1)

#try

import random


class SimpleVirus(object):
    def __init__(self, maxBirthProb, clearProb):
        self.maxBirthProb = maxBirthProb
        self.clearProb = clearProb

    def getMaxBirthProb(self):
        return self.maxBirthProb

    def getClearProb(self):
        return self.clearProb

    def doesClear(self):
        random.seed(1)
        return random.random() < min(1, self.getClearProb())

    def reproduce(self, popDensity):
        random.seed(1)
        if random.random() < self.maxBirthProb * (1 - popDensity):
            return SimpleVirus(self.maxBirthProb, self.clearProb)
        elif self.maxBirthProb == 0:
            raise NoChildException
        else:
            raise NoChildException



class Patient(object):

    def __init__(self, viruses, maxPop):
      self.viruses = viruses
      self.maxPop = maxPop

    def getViruses(self):
        return self.viruses

    def getMaxPop(self):
        return self.maxPop

    def getTotalPop(self):
        return len(self.viruses)

    def update(self):
        surviving_viruses = [virus for virus in self.viruses if not virus.doesClear()]

        if len(surviving_viruses) == 0:
            return 0

        density = len(surviving_viruses) / self.getMaxPop()

        new_viruses = []

        for virus in surviving_viruses:
            try:
                newgen = virus.reproduce(density)
                if newgen:
                    new_viruses.append(newgen)
            except NoChildException:
                pass

        self.viruses.extend(new_viruses)

        return self.getTotalPop()

import random

def F():
    mylist = []
    r = 1

    if random.random() > 0.99:
        r = random.randint(1, 10)
    for i in range(r):
        random.seed(0)
        if random.randint(1, 10) > 3:
            number = random.randint(1, 10)
            if number not in mylist:
                mylist.append(number)
    print(mylist)

def G():
    random.seed(0)
    mylist = []
    r = 1

    if random.random() > 0.99:
        r = random.randint(1, 10)
    for i in range(r):
        if random.randint(1, 10) > 3:
            number = random.randint(1, 10)
            mylist.append(number)
            print(mylist)

import pylab

class Location(object):
    def __init__(self, x, y):
        """x and y are floats"""
        self.x = x
        self.y = y

    def move(self, deltaX, deltaY):
        """deltaX and deltaY are floats"""
        return Location(self.x + deltaX, self.y + deltaY)

    def getX(self):
        return self.x

    def getY(self):
        return self.y

    def distFrom(self, other):
        ox = other.x
        oy = other.y
        xDist = self.x - ox
        yDist = self.y - oy
        return (xDist**2 + yDist**2)**0.5

    def __str__(self):
        return '<' + str(self.x) + ', ' + str(self.y) + '>'

class Field(object):
    def __init__(self):
        self.drunks = {}

    def addDrunk(self, drunk, loc):
        if drunk in self.drunks:
            raise ValueError('Duplicate drunk')
        else:
            self.drunks[drunk] = loc

    def moveDrunk(self, drunk):
        if not drunk in self.drunks:
            raise ValueError('Drunk not in field')
        xDist, yDist = drunk.takeStep()
        currentLocation = self.drunks[drunk]
        #use move method of Location to get new location
        self.drunks[drunk] = currentLocation.move(xDist, yDist)

    def getLoc(self, drunk):
        if not drunk in self.drunks:
            raise ValueError('Drunk not in field')
        return self.drunks[drunk]


import random

class Drunk(object):
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return 'This drunk is named ' + self.name

import random
import math
import matplotlib.pyplot as plt

def takeStep():
    ang = 2 * math.pi * random.random()
    length = 0.5 + 0.5 * random.random()
    return (length * math.sin(ang), length * math.cos(ang))

res = [takeStep() for _ in range(500)]
x_values, y_values = zip(*res)

plt.scatter(x_values, y_values, c='blue', marker='.')

plt.xlabel('X Koordinatı')
plt.ylabel('Y Koordinatı')

plt.show()

def max_contig_sum(L):
    m_sum = float('-inf')

    for x in range(len(L)):
        for y in range(x + 1, len(L) + 1):
            cur_sum = sum(L[x:y])
            m_sum = max(m_sum, cur_sum)

    return m_sum

L = [3, 4, 8, 5, -4]
max_contig_sum(L)

def song_playlist(songs, max_size):
    playlist = []
    if songs[0][2] <= max_size:
        playlist.append(songs[0][0])
    else:
        return playlist
    song_list_copy_ascending = sorted(songs, key = lambda x: x[2])
    song_list_copy_ascending.remove(songs[0])
    space_remain = max_size - songs[0][2]
    for i in song_list_copy_ascending:
        if i[2] <= space_remain:
            playlist.append(i[0])
            space_remain -= i[2]
        else:
            break
    return playlist
song_playlist([('z', 0.1, 0.1), ('a', 4.4, 4.0), ('b', 3.5, 7.7), ('c', 5.1, 6.9), ('d', 2.7, 1.2)], 1)

def solveit(test):
    """
    test, a function that takes an int parameter and returns a Boolean
    Assumes there exists an int, x, such that test(x) is True
    Returns an int, x, with the smallest absolute value such that test(x) is True
    In case of ties, return any one of them.
    """
    low, high = 0, 1

    # Find an interval [low, high] where test(low) is False and test(high) is True
    while not test(high):
        low = high
        high *= 2
        if high > 10**18:  # Stop if 'high' becomes too large
            break

    # Perform binary search to find the smallest x such that test(x) is True
    while low < high:
        mid = (low + high) // 2
        if test(mid):
            high = mid
        else:
            low = mid + 1

    return low

# Test case 1
def f1(x):
    return (x+15)**0.5 + x**0.5 == 15
print(solveit(f1))  # Output: 49

# Test case 2
def f2(x):
    return x == 0
print(solveit(f2))  # Output: 0

import math
import random
import pylab

class Position(object):
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def getX(self):
        return self.x

    def getY(self):
        return self.y

    def getNewPosition(self, angle, speed):
        old_x, old_y = self.getX(), self.getY()
        angle = float(angle)
        delta_y = speed * math.cos(math.radians(angle))
        delta_x = speed * math.sin(math.radians(angle))
        new_x = old_x + delta_x
        new_y = old_y + delta_y
        return Position(new_x, new_y)

    def __str__(self):
        return "(%0.2f, %0.2f)" % (self.x, self.y)


# === Problem 1
class RectangularRoom(object):
    def __init__(self, width, height):
      self.width = width
      self.height = height
      self.cleaned = []

    def cleanTileAtPosition(self, pos):
        if self.isPositionInRoom(pos):
          if (int(pos.x), int(pos.y)) not in self.cleaned:
            self.cleaned.append((int(pos.x), int(pos.y)))

    def isTileCleaned(self, m, n):
        self.m = m
        self.n = n
        tile = (self.m, self.n)
        if tile in self.cleaned:
            return True
        else:
            return False

    def getNumTiles(self):
        return self.width * self.height

    def getNumCleanedTiles(self):
        return len(self.cleaned)

    def getRandomPosition(self):
        x = random.randint(0,self.width-1)
        y = random.randint(0,self.height-1)
        return Position(x, y)

    def isPositionInRoom(self, pos):
        if pos.x >= 0 and pos.x < self.width and pos.y >= 0 and pos.y < self.height:
          return True
        else:
          return False


class Robot(object):

    def __init__(self, room, speed):
        """
        Initializes a Robot with the given speed in the specified room. The
        robot initially has a random direction and a random position in the
        room. The robot cleans the tile it is on.

        room:  a RectangularRoom object.
        speed: a float (speed > 0)
        """
        self.room = room
        self.speed = speed
        self.pos = room.getRandomPosition()
        self.direction = random.randint(0, 359)
        self.room.cleanTileAtPosition(self.pos)

    def getRobotPosition(self):
        return self.pos

    def getRobotDirection(self):
        return self.direction

    def setRobotPosition(self, position):
        self.pos = position

    def setRobotDirection(self, direction):
        self.direction = direction

    def updatePositionAndClean(self):
        raise NotImplementedError # don't change this!

class StandardRobot(Robot):
    def updatePositionAndClean(self):

        next_pos = self.getRobotPosition().getNewPosition(self.getRobotDirection(), self.speed)
        if self.room.isPositionInRoom(next_pos) == False:
            self.setRobotDirection(random.randint(0, 359))
        else:
            self.setRobotPosition(next_pos)
            self.room.cleanTileAtPosition(next_pos)

def runSimulation(num_robots, speed, width, height, min_coverage, num_trials, robot_type):
    """
    num_robots: an int (num_robots > 0)
    speed: a float (speed > 0)
    width: an int (width > 0)
    height: an int (height > 0)
    min_coverage: a float (0 <= min_coverage <= 1.0)
    num_trials: an int (num_trials > 0)
    robot_type: class of robot to be instantiated (e.g. StandardRobot or
                RandomWalkRobot)
    """
    results = []
    for x in range(num_trials):
        num_steps = 0
        room = RectangularRoom(width, height)
        robots = [robot_type(room, speed) for y in range(num_robots)]
        while (room.getNumCleanedTiles()/room.getNumTiles()) < min_coverage:
            num_steps += 1
            for k in robots:
                k.updatePositionAndClean()
            if (room.getNumCleanedTiles()/room.getNumTiles()) >= min_coverage:
                results.append(num_steps)
            else:
                continue
    return sum(results)/len(results)


class RandomWalkRobot(Robot):
    def updatePositionAndClean(self):
        next_position = self.getRobotPosition().getNewPosition(random.randint(0, 359), self.speed)
        if self.room.isPositionInRoom(next_position) == False:
            self.setRobotDirection(random.randint(0, 359))
        else:
            self.setRobotPosition(next_position)
            self.setRobotDirection(random.randint(0, 359))
            self.room.cleanTileAtPosition(next_position)


import math
import time

from tkinter import *

class RobotVisualization:
    def __init__(self, num_robots, width, height, delay = 0.2):
        "Initializes a visualization with the specified parameters."
        # Number of seconds to pause after each frame
        self.delay = delay

        self.max_dim = max(width, height)
        self.width = width
        self.height = height
        self.num_robots = num_robots

        # Initialize a drawing surface
        self.master = Tk()
        self.w = Canvas(self.master, width=500, height=500)
        self.w.pack()
        self.master.update()

        # Draw a backing and lines
        x1, y1 = self._map_coords(0, 0)
        x2, y2 = self._map_coords(width, height)
        self.w.create_rectangle(x1, y1, x2, y2, fill = "white")

        # Draw gray squares for dirty tiles
        self.tiles = {}
        for i in range(width):
            for j in range(height):
                x1, y1 = self._map_coords(i, j)
                x2, y2 = self._map_coords(i + 1, j + 1)
                self.tiles[(i, j)] = self.w.create_rectangle(x1, y1, x2, y2,
                                                             fill = "gray")

        # Draw gridlines
        for i in range(width + 1):
            x1, y1 = self._map_coords(i, 0)
            x2, y2 = self._map_coords(i, height)
            self.w.create_line(x1, y1, x2, y2)
        for i in range(height + 1):
            x1, y1 = self._map_coords(0, i)
            x2, y2 = self._map_coords(width, i)
            self.w.create_line(x1, y1, x2, y2)

        # Draw some status text
        self.robots = None
        self.text = self.w.create_text(25, 0, anchor=NW,
                                       text=self._status_string(0, 0))
        self.time = 0
        self.master.update()

    def _status_string(self, time, num_clean_tiles):
        "Returns an appropriate status string to print."
        percent_clean = round(100 * num_clean_tiles / (self.width * self.height))
        return "Time: %04d; %d tiles (%d%%) cleaned" % \
            (time, num_clean_tiles, percent_clean)

    def _map_coords(self, x, y):
        "Maps grid positions to window positions (in pixels)."
        return (250 + 450 * ((x - self.width / 2.0) / self.max_dim),
                250 + 450 * ((self.height / 2.0 - y) / self.max_dim))

    def _draw_robot(self, position, direction):
        "Returns a polygon representing a robot with the specified parameters."
        x, y = position.getX(), position.getY()
        d1 = direction + 165
        d2 = direction - 165
        x1, y1 = self._map_coords(x, y)
        x2, y2 = self._map_coords(x + 0.6 * math.sin(math.radians(d1)),
                                  y + 0.6 * math.cos(math.radians(d1)))
        x3, y3 = self._map_coords(x + 0.6 * math.sin(math.radians(d2)),
                                  y + 0.6 * math.cos(math.radians(d2)))
        return self.w.create_polygon([x1, y1, x2, y2, x3, y3], fill="red")

    def update(self, room, robots):
        "Redraws the visualization with the specified room and robot state."
        # Removes a gray square for any tiles have been cleaned.
        for i in range(self.width):
            for j in range(self.height):
                if room.isTileCleaned(i, j):
                    self.w.delete(self.tiles[(i, j)])
        # Delete all existing robots.
        if self.robots:
            for robot in self.robots:
                self.w.delete(robot)
                self.master.update_idletasks()
        # Draw new robots
        self.robots = []
        for robot in robots:
            pos = robot.getRobotPosition()
            x, y = pos.getX(), pos.getY()
            x1, y1 = self._map_coords(x - 0.08, y - 0.08)
            x2, y2 = self._map_coords(x + 0.08, y + 0.08)
            self.robots.append(self.w.create_oval(x1, y1, x2, y2,
                                                  fill = "black"))
            self.robots.append(
                self._draw_robot(robot.getRobotPosition(), robot.getRobotDirection()))
        # Update text
        self.w.delete(self.text)
        self.time += 1
        self.text = self.w.create_text(
            25, 0, anchor=NW,
            text=self._status_string(self.time, room.getNumCleanedTiles()))
        self.master.update()
        time.sleep(self.delay)

    def done(self):
        "Indicate that the animation is done so that we allow the user to close the window."
        mainloop()

x = 0.6
int(x)

import matplotlib.pyplot as plt
import pandas as pd

data = pd.read_csv('data.csv')
data.head()

data.shape

y = data['TEMP'][:100]
x = data['DATE'][:100]
plt.plot(x, y)
plt.title('Seattle temp. for 1 year')
plt.show()

import numpy as np
import pylab
import re

CITIES = [
    'BOSTON',
    'SEATTLE',
    'SAN DIEGO',
    'PHILADELPHIA',
    'PHOENIX',
    'LAS VEGAS',
    'CHARLOTTE',
    'DALLAS',
    'BALTIMORE',
    'SAN JUAN',
    'LOS ANGELES',
    'MIAMI',
    'NEW ORLEANS',
    'ALBUQUERQUE',
    'PORTLAND',
    'SAN FRANCISCO',
    'TAMPA',
    'NEW YORK',
    'DETROIT',
    'ST LOUIS',
    'CHICAGO'
]

INTERVAL_1 = list(range(1961, 2006))
INTERVAL_2 = list(range(2006, 2016))


class Climate(object):
    def __init__(self, filename):
        self.rawdata = {}

        f = open(filename, 'r')
        header = f.readline().strip().split(',')
        for line in f:
            items = line.strip().split(',')

            date = re.match('(\d\d\d\d)(\d\d)(\d\d)', items[header.index('DATE')])
            year = int(date.group(1))
            month = int(date.group(2))
            day = int(date.group(3))

            city = items[header.index('CITY')]
            temperature = float(items[header.index('TEMP')])
            if city not in self.rawdata:
                self.rawdata[city] = {}
            if year not in self.rawdata[city]:
                self.rawdata[city][year] = {}
            if month not in self.rawdata[city][year]:
                self.rawdata[city][year][month] = {}
            self.rawdata[city][year][month][day] = temperature

        f.close()

    def get_yearly_temp(self, city, year):
        """
        Get the daily temperatures for the given year and city.

        Args:
            city: city name (str)
            year: the year to get the data for (int)

        Returns:
            a numpy 1-d array of daily temperatures for the specified year and
            city
        """
        temperatures = []
        assert city in self.rawdata, "provided city is not available"
        assert year in self.rawdata[city], "provided year is not available"
        for month in range(1, 13):
            for day in range(1, 32):
                if day in self.rawdata[city][year][month]:
                    temperatures.append(self.rawdata[city][year][month][day])
        return np.array(temperatures)

    def get_daily_temp(self, city, month, day, year):
        """
        Get the daily temperature for the given city and time (year + date).

        Args:
            city: city name (str)
            month: the month to get the data for (int, where January = 1,
                December = 12)
            day: the day to get the data for (int, where 1st day of month = 1)
            year: the year to get the data for (int)

        Returns:
            a float of the daily temperature for the specified time (year +
            date) and city
        """
        assert city in self.rawdata, "provided city is not available"
        assert year in self.rawdata[city], "provided year is not available"
        assert month in self.rawdata[city][year], "provided month is not available"
        assert day in self.rawdata[city][year][month], "provided day is not available"
        return self.rawdata[city][year][month][day]


def generate_models(x, y, degs):
    """
    Generate regression models by fitting a polynomial for each degree in degs
    to points (x, y).
    """
    return [np.polyfit(x, y, z) for z in degs]

def r_squared(y, estimated):
    y, est = np.array(y), np.array(estimated)
    acc = ((y - est)**2).sum()
    mean = y.sum()/len(y)
    meanval = ((y - mean)**2).sum()
    return 1 - acc/meanval

y = []
x = INTERVAL_1
for year in INTERVAL_1:
    y.append(raw_data.get_daily_temp('BOSTON', 1, 10, year))
models = generate_models(x, y, [1])
evaluate_models_on_training(x, y, models)